package main

import (
	"fmt"
)

//Реализовать быструю сортировку массива (quicksort) встроенными методами языка.

/*
В среднем и в лучшем случаях быстрая сортировка выполняется за время O(n log n)
Это происходит из-за того, что на каждом шаге алгоритма массив делится пополам
В худшем случае(когда массив уже отсортирован или отсортирован в порядке убывания)
время выполнения будет O(n^2)
*/
func quickSort(arr []int) []int {
	/*
		Если длина массива меньше или равна единице,
		то массив уже отсортирован,
		просто возвращаем его без изменений
	*/
	if len(arr) <= 1 {
		return arr
	}

	/*
		Выбрал первый элемента в качестве опорного
		из-за минимальных затрат вычисления
	*/
	pivot := arr[0]

	/*
		Создаем два пустых слайса left и right,
		в которые будут добавляться элементы меньше и равные опорному(left)
		и элементы больше опорного(right)
	*/
	var left, right []int

	// Проходим по всем элементам массива arr начиная с индекса 1
	for _, num := range arr[1:] {
		/*
			Если элемент меньше или равен опорному элементу,
			то он добавляется в слайс left и цикл переходит на следующую итерацию
		*/
		if num <= pivot {
			left = append(left, num)
			continue
		}
		// Если условие if не выполнилось, то элемент больше опорного, он добавляется в слайс right
		right = append(right, num)
	}

	/*
		Рекурсивно вызываем функцию quickSort для слайсов left и right,
		тем самым разбиваем массив на еще более мелкие части и продолжаем
		процесс сортировки
	*/
	sortedLeft := quickSort(left)
	sortedRight := quickSort(right)

	// Собираем массив обратно объединяя отсортированные слайсы и опорную точку по порядку
	return append(append(sortedLeft, pivot), sortedRight...)
}

func main() {
	arr := []int{9, 3, 7, 5, 1, 2, 6, 8, 4}
	fmt.Printf("Original: %v\n", arr)
	fmt.Printf("Sorted: %v\n", quickSort(arr))
}

package main

import "fmt"

// Реализовать бинарный поиск встроенными методами языка.

// Бинарный поиск возможен только в отсортированном массиве

/*
	Бинарный поиск рекурсивно делит массив пополам и выполняет
	поиск требуемого элемента в подходящей половине массива
	до тех пор пока искомый элемент не будет найден или до тех
	пор, пока не выполнится базовый случай
*/

func binarySearch(arr []int, search int) bool {
	// Если длина массива равна 0, то есть нет ни одного элемента, возвращаем false
	// Базовый случай
	if len(arr) == 0 {
		return false
	}

	// Находим середину массива
	mid := len(arr) / 2

	switch {
	// Если элемент больше искомого значения, то он находится во второй половине массива
	case arr[mid] > search:
		// Рекурсивно запускаем с тем же искомым элементом бинарный поиск обрезав массив до начала второй половины
		return binarySearch(arr[:mid], search)
		// Если элемент меньше искомого значения, то он находится в первой половине массива
	case arr[mid] < search:
		// Рекурсивно запускаем с тем же искомым элементом бинарный поиск обрезав вторую половину массива
		return binarySearch(arr[mid+1:], search)
		// Если arr[mid](центр) равен искомому значению то возвращаем true, элемент найден
	default:
		return true
	}
}

/*
Если элемент найден то будет возвращен true в результате всех рекурсивных вызовов
Если элемента нет в массиве то рекурсия будет продолжаться до тех пор,
пока не выполнится базовый случай
*/

func main() {
	arr := []int{1, 2, 3, 4, 5, 6, 7, 8}
	fmt.Println(binarySearch(arr, 7))
}
